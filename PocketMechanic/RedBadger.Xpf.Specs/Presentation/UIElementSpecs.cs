//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------
#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.Presentation
{
    using System;

    using RedBadger.Xpf.Presentation;

    using Machine.Specifications;

    using Rhino.Mocks;

    public abstract class a_UIElement
    {
        protected static UIElement uiElement;

        private Establish context = () => uiElement = MockRepository.GenerateStub<UIElement>();
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_the_supplied_available_size_Width_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(new Size(float.NaN, 0)));

        private It should_throw_a_Exception =
            () => exception.ShouldBeOfType<InvalidOperationException>();
    }
    
    [Subject(typeof(UIElement), "Measuring")]
    public class when_the_supplied_available_size_Height_is_not_a_number : a_UIElement
    {
        private static Exception exception;

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(new Size(0, float.NaN)));

        private It should_throw_a_Exception =
            () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_measuring : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private static Size originalDesiredSize;

        private Establish context = () =>
            {
                originalDesiredSize = uiElement.DesiredSize;
                uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(5, 5));
            };

        private Because of = () => uiElement.Measure(availableSize);

        private It should_invalidate_arrange = () => uiElement.IsArrangeValid.ShouldBeFalse();

        private It should_be_marked_as_having_a_valid_Measure = () => uiElement.IsMeasureValue.ShouldBeTrue();

        private It should_have_a_desired_size_set = () => uiElement.DesiredSize.ShouldNotEqual(originalDesiredSize);
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_an_implementing_control_returns_a_size_greater_than_the_available_size : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(95, 100));

        private Because of = () => uiElement.Measure(availableSize);

        private It should_reduce_the_size_returned_to_keep_it_within_the_available_size_passed_to_Measure =
            () => uiElement.DesiredSize.ShouldEqual(availableSize);
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_an_implementing_control_returns_a_negative_size : a_UIElement
    {
        private static readonly Size availableSize = new Size(10, 10);

        private Establish context =
            () => uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(new Size(-10, -10));

        private Because of = () => uiElement.Measure(availableSize);

        private It should_return_a_zero_value_instead = () => uiElement.DesiredSize.ShouldEqual(Size.Empty);
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_an_implementing_control_returns_a_width_of_positive_infinity : a_UIElement
    {
        private static Exception exception;

        private static readonly Size availableSize = new Size(float.PositiveInfinity, float.PositiveInfinity);

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(float.PositiveInfinity, 0));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    [Subject(typeof(UIElement), "Measuring")]
    public class when_an_implementing_control_returns_a_height_of_positive_infinity : a_UIElement
    {
        private static Exception exception;

        private static readonly Size availableSize = new Size(float.PositiveInfinity, float.PositiveInfinity);

        private Establish context =
            () =>
            uiElement.Expect(element => element.MeasureOverride(availableSize)).Return(
                new Size(0, float.PositiveInfinity));

        private Because of = () => exception = Catch.Exception(() => uiElement.Measure(availableSize));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<InvalidOperationException>();
    }

    internal static class UIElementMockingExtensions
    {
        public static Size MeasureOverride(this UIElement element, Size availableSize)
        {
            var result =
                typeof(UIElement).GetMethod(
                    "MeasureOverride",
                    System.Reflection.BindingFlags.Instance | System.Reflection.BindingFlags.NonPublic,
                    null,
                    new[] { typeof(Size) },
                    null).Invoke(element, new object[] { availableSize });

            return (Size)result;
        }
    }
}