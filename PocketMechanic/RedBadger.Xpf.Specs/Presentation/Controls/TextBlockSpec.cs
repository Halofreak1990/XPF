//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.Presentation.Controls
{
    using Machine.Specifications;

    using Microsoft.Xna.Framework;

    using Moq;

    using RedBadger.Xpf.Graphics;
    using RedBadger.Xpf.Presentation;
    using RedBadger.Xpf.Presentation.Controls;

    using It = Machine.Specifications.It;

    public abstract class a_TextBlock
    {
        protected static RootElement RootElement;

        protected static Mock<ISpriteBatch> SpriteBatch;

        protected static Mock<ISpriteFont> SpriteFont;

        protected static TextBlock TextBlock;

        private Establish context = () =>
            {
                SpriteBatch = new Mock<ISpriteBatch>();
                SpriteFont = new Mock<ISpriteFont>();
                RootElement = new RootElement(new Rect(Vector2.Zero, new Size(100, 100)));
                TextBlock = new TextBlock(SpriteFont.Object);
                RootElement.Content = TextBlock;
            };
    }

    [Subject(typeof(TextBlock), "Formatting")]
    public class when_foreground_is_not_specified : a_TextBlock
    {
        private Because of = () =>
            {
                RootElement.Update();
                RootElement.Draw(SpriteBatch.Object);
            };

        private It should_default_to_black =
            () =>
            SpriteBatch.Verify(
                batch =>
                batch.DrawString(SpriteFont.Object, Moq.It.IsAny<string>(), Moq.It.IsAny<Vector2>(), Color.Black));
    }

    [Subject(typeof(TextBlock), "Formatting")]
    public class when_foreground_is_specified : a_TextBlock
    {
        private static Color expectedForeground;

        private Because of = () =>
            {
                expectedForeground = Color.White;
                TextBlock.Foreground = expectedForeground;
                RootElement.Update();
                RootElement.Draw(SpriteBatch.Object);
            };

        private It should_use_the_color_specified =
            () =>
            SpriteBatch.Verify(
                batch =>
                batch.DrawString(SpriteFont.Object, Moq.It.IsAny<string>(), Moq.It.IsAny<Vector2>(), expectedForeground));
    }

    [Subject(typeof(TextBlock), "Formatting")]
    public class when_padding_is_specified : a_TextBlock
    {
        private static readonly Size expectedDesiredSize = new Size(50, 70);

        private static readonly Vector2 expectedDrawPosition = new Vector2(10, 20);

        private static readonly Thickness padding = new Thickness(10, 20, 30, 40);

        private static readonly Vector2 stringSize = new Vector2(10, 10);

        private Establish context = () =>
            {
                TextBlock.HorizontalAlignment = HorizontalAlignment.Left;
                TextBlock.VerticalAlignment = VerticalAlignment.Top;
                SpriteFont.Setup(font => font.MeasureString(Moq.It.IsAny<string>())).Returns(stringSize);
            };

        private Because of = () =>
            {
                TextBlock.Padding = padding;
                RootElement.Update();
                RootElement.Draw(SpriteBatch.Object);
            };

        private It should_increase_the_desired_size = () => TextBlock.DesiredSize.ShouldEqual(expectedDesiredSize);

        private It should_take_padding_into_account_when_drawing =
            () =>
            SpriteBatch.Verify(
                batch =>
                batch.DrawString(SpriteFont.Object, Moq.It.IsAny<string>(), expectedDrawPosition, Moq.It.IsAny<Color>()));
    }
}