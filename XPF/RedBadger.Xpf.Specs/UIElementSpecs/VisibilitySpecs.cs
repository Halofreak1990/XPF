//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.UIElementSpecs
{
    using Machine.Specifications;

    using Moq;
    using Moq.Protected;

    using It = Machine.Specifications.It;

    [Subject(typeof(UIElement), "Visibility")]
    public class when_an_element_has_default_visibility : a_UIElement
    {
        private It should_have_a_visibility_of_visible = () => Subject.Object.Visibility.ShouldEqual(Visibility.Visible);
    }

    [Subject(typeof(UIElement), "Visibility")]
    public class when_visibility_is_set_to_collapsed : a_UIElement
    {
        private Establish context = () => Subject.Object.Visibility = Visibility.Collapsed;

        private Because of = () =>
            {
                Subject.Object.Measure(AvailableSize);
                Subject.Object.Arrange(new Rect(AvailableSize));
            };

        private It should_not_call_arrange_override =
            () => Subject.Protected().Verify(ArrangeOverride, Times.Never(), ItExpr.IsAny<Size>());

        private It should_not_call_measure_override =
            () => Subject.Protected().Verify(MeasureOverride, Times.Never(), ItExpr.IsAny<Size>());
    }

    [Subject(typeof(UIElement), "Visibility - Size Change")]
    public class when_the_element_is_made_visible_again :
        a_collapsed_measured_and_arranged_UIElement_in_a_RootElement
    {
        private Because of = () =>
            {
                Subject.Object.Visibility = Visibility.Visible;
                RootElement.Object.Update();
            };

        private It should_call_arrange_override =
            () => Subject.Protected().Verify(ArrangeOverride, Times.Exactly(2), ItExpr.IsAny<Size>());

        private It should_call_measure_override =
            () => Subject.Protected().Verify(MeasureOverride, Times.Exactly(2), ItExpr.IsAny<Size>());
    }

    [Subject(typeof(UIElement), "Visibility - Size Change")]
    public class when_the_element_is_collapsed_and_the_available_size_changes :
        a_collapsed_measured_and_arranged_UIElement_in_a_RootElement
    {
        private Because of = () => Subject.Object.Measure(AvailableSize + AvailableSize);

        private It should_invalidate_its_own_measure = () => Subject.Object.IsMeasureValid.ShouldBeFalse();

        private It should_not_invalidate_its_parents_measure =
            () => Subject.Object.VisualParent.IsMeasureValid.ShouldBeTrue();
    }

    [Subject(typeof(UIElement), "Visibility - Size Change")]
    public class when_the_element_is_collapsed_and_the_available_size_doesnt_change_enough :
        a_collapsed_measured_and_arranged_UIElement_in_a_RootElement
    {
        private Because of = () => Subject.Object.Measure(AvailableSize + new Size(1e-13d, 1e-13d));

        private It should_not_invalidate_its_own_measure = () => Subject.Object.IsMeasureValid.ShouldBeTrue();

        private It should_not_invalidate_its_parents_measure =
            () => Subject.Object.VisualParent.IsMeasureValid.ShouldBeTrue();
    }

    [Subject(typeof(UIElement), "Visibility - Size Change")]
    public class when_the_element_is_collapsed_and_the_final_size_changes :
        a_collapsed_measured_and_arranged_UIElement_in_a_RootElement
    {
        private Because of = () => Subject.Object.Arrange(new Rect(FinalSize + FinalSize));

        private It should_invalidate_its_own_arrange = () => Subject.Object.IsArrangeValid.ShouldBeFalse();

        private It should_not_invalidate_its_parents_measure =
            () => Subject.Object.VisualParent.IsMeasureValid.ShouldBeTrue();
    }

    [Subject(typeof(UIElement), "Visibility - Size Change")]
    public class when_the_element_is_collapsed_and_the_final_size_doesnt_change_enough :
        a_collapsed_measured_and_arranged_UIElement_in_a_RootElement
    {
        private Because of = () => Subject.Object.Arrange(new Rect(FinalSize + new Size(1e-13d, 1e-13d)));

        private It should_not_invalidate_its_own_arrange = () => Subject.Object.IsArrangeValid.ShouldBeTrue();

        private It should_not_invalidate_its_parents_measure =
            () => Subject.Object.VisualParent.IsMeasureValid.ShouldBeTrue();
    }
}