//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.Presentation.ReactiveObjectSpecs.BindingSpecs.ReactiveObjectSpecs
{
    using System;

    using Machine.Specifications;

    using RedBadger.Xpf.Presentation;
    using RedBadger.Xpf.Presentation.Controls;
    using RedBadger.Xpf.Presentation.Data;
    using RedBadger.Xpf.Presentation.Media;

    public class TestBindingObject : ReactiveObject
    {
        public static readonly ReactiveProperty<Brush, TestBindingObject> BrushProperty =
            ReactiveProperty<Brush, TestBindingObject>.Register("Brush");

        public static readonly ReactiveProperty<SolidColorBrush, TestBindingObject> SolidColorBrushProperty =
            ReactiveProperty<SolidColorBrush, TestBindingObject>.Register("SolidColorBrush");

        public static readonly ReactiveProperty<double, TestBindingObject> WidthProperty =
            ReactiveProperty<double, TestBindingObject>.Register("Width", double.NaN, WidthChangedCallback);

        private int widthPropertyChangedCalledbackCount;

        public Brush Brush
        {
            get
            {
                return this.GetValue(BrushProperty);
            }

            set
            {
                this.SetValue(BrushProperty, value);
            }
        }

        public SolidColorBrush SolidColorBrush
        {
            get
            {
                return this.GetValue(SolidColorBrushProperty);
            }

            set
            {
                this.SetValue(SolidColorBrushProperty, value);
            }
        }

        public double Width
        {
            get
            {
                return this.GetValue(WidthProperty);
            }

            set
            {
                this.SetValue(WidthProperty, value);
            }
        }

        public int WidthPropertyChangedCalledbackCount
        {
            get
            {
                return this.widthPropertyChangedCalledbackCount;
            }
        }

        private static void WidthChangedCallback(
            TestBindingObject testBindingObject, 
            ReactivePropertyChangeEventArgs<double, TestBindingObject> reactivePropertyChange)
        {
            testBindingObject.widthPropertyChangedCalledbackCount++;
        }
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_property_on_the_data_context
    {
        private const double ExpectedWidth = 10d;

        private static TestBindingObject source;

        private static ContentControl target;

        private Establish context = () =>
            {
                target = new ContentControl();

                IObservable<double> fromSource = BindingFactory.CreateOneWay(TestBindingObject.WidthProperty);
                target.Bind(UIElement.WidthProperty, fromSource);

                source = new TestBindingObject();
                target.DataContext = source;
                target.Measure(Size.Empty);
            };

        private Because of = () => source.Width = ExpectedWidth;

        private It should_update_the_target = () => target.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_there_is_a_one_way_binding_to_a_property_on_a_specified_source
    {
        private const double ExpectedWidth = 10d;

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObservable<double> fromSource = BindingFactory.CreateOneWay(source, TestBindingObject.WidthProperty);
                target.Bind(UIElement.WidthProperty, fromSource);
            };

        private Because of = () => source.Width = ExpectedWidth;

        private It should_update_the_target = () => target.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_a_binding_is_one_way_and_the_source_property_type_is_more_derived
    {
        private static readonly SolidColorBrush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObservable<Brush> fromSource = BindingFactory.CreateOneWay(
                    source, TestBindingObject.SolidColorBrushProperty);
                target.Bind(Border.BorderBrushProperty, fromSource);
            };

        private Because of = () => source.SolidColorBrush = expectedBrush;

        private It should_update_the_target = () => target.BorderBrush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_a_one_way_binding_to_a_property_on_a_specified_source_is_cleared
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObservable<Brush> fromSource = BindingFactory.CreateOneWay(source, TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, fromSource);
            };

        private Because of = () =>
            {
                source.Brush = expectedBrush;
                target.ClearBinding(Border.BorderBrushProperty);

                source.Brush = new SolidColorBrush(Colors.Black);
            };

        private It should_not_use_the_binding = () => target.BorderBrush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way")]
    public class when_a_one_way_binding_to_a_property_on_the_data_context_is_cleared
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border { DataContext = source };

                IObservable<Brush> fromSource = BindingFactory.CreateOneWay(TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, fromSource);
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                source.Brush = expectedBrush;
                target.ClearBinding(Border.BorderBrushProperty);

                source.Brush = new SolidColorBrush(Colors.Black);
            };

        private It should_not_use_the_binding = () => target.BorderBrush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_there_is_a_one_way_to_source_binding_to_the_data_context
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border { DataContext = source };

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, toSource);
                target.Measure(Size.Empty);
            };

        private Because of = () => target.BorderBrush = expectedBrush;

        private It should_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_a_one_way_to_source_binding_to_the_data_context_is_cleared
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border { DataContext = source };

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, toSource);
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                target.BorderBrush = expectedBrush;
                target.ClearBinding(Border.BorderBrushProperty);

                target.BorderBrush = new SolidColorBrush(Colors.Yellow);
            };

        private It should_not_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_there_is_a_one_way_to_source_binding_to_a_specified_source
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(source, TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, toSource);
            };

        private Because of = () => target.BorderBrush = expectedBrush;

        private It should_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_a_one_way_to_source_binding_to_a_specified_source_is_cleared
    {
        private static readonly Brush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(source, TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, toSource);
            };

        private Because of = () =>
            {
                target.BorderBrush = expectedBrush;
                target.ClearBinding(Border.BorderBrushProperty);

                target.BorderBrush = new SolidColorBrush(Colors.Yellow);
            };

        private It should_not_update_the_source = () => source.Brush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "One Way To Source")]
    public class when_a_binding_is_one_way_to_source_and_the_type_of_the_target_property_is_derived
    {
        private static readonly SolidColorBrush expectedBrush = new SolidColorBrush(Colors.Brown);

        private static Border source;

        private static TestBindingObject target;

        private Establish context = () =>
            {
                target = new TestBindingObject();
                source = new Border();

                IObserver<Brush> toSource = BindingFactory.CreateOneWayToSource(source, Border.BorderBrushProperty);
                target.Bind(TestBindingObject.SolidColorBrushProperty, toSource);
            };

        private Because of = () => target.SolidColorBrush = expectedBrush;

        private It should_update_the_source = () => source.BorderBrush.ShouldEqual(expectedBrush);
    }

    [Subject(typeof(ReactiveObject), "Two Way")]
    public class when_a_binding_is_two_way_to_a_property_on_the_data_context
    {
        private static readonly Brush expectedSourceBrush = new SolidColorBrush(Colors.Blue);

        private static readonly Brush expectedTargetBrush = new SolidColorBrush(Colors.Red);

        private static Brush actualBrushOnSource;

        private static Brush actualBrushOnTarget;

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IDualChannel<Brush> twoWay = BindingFactory.CreateTwoWay(TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, twoWay);

                target.DataContext = source;
                target.Measure(Size.Empty);
            };

        private Because of = () =>
            {
                target.BorderBrush = expectedTargetBrush;
                actualBrushOnSource = source.Brush;

                source.Brush = expectedSourceBrush;
                actualBrushOnTarget = target.BorderBrush;
            };

        private It should_update_the_source = () => actualBrushOnSource.ShouldEqual(expectedTargetBrush);

        private It should_update_the_target = () => actualBrushOnTarget.ShouldEqual(expectedSourceBrush);
    }

    [Subject(typeof(ReactiveObject), "Two Way")]
    public class when_a_binding_is_two_way_to_a_property_on_a_specified_source
    {
        private static readonly Brush expectedSourceBrush = new SolidColorBrush(Colors.Blue);

        private static readonly Brush expectedTargetBrush = new SolidColorBrush(Colors.Red);

        private static Brush actualBrushOnSource;

        private static Brush actualBrushOnTarget;

        private static TestBindingObject source;

        private static Border target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new Border();

                IDualChannel<Brush> twoWay = BindingFactory.CreateTwoWay(source, TestBindingObject.BrushProperty);
                target.Bind(Border.BorderBrushProperty, twoWay);
            };

        private Because of = () =>
            {
                target.BorderBrush = expectedTargetBrush;
                actualBrushOnSource = source.Brush;

                source.Brush = expectedSourceBrush;
                actualBrushOnTarget = target.BorderBrush;
            };

        private It should_update_the_source = () => actualBrushOnSource.ShouldEqual(expectedTargetBrush);

        private It should_update_the_target = () => actualBrushOnTarget.ShouldEqual(expectedSourceBrush);
    }

    [Subject(typeof(ReactiveObject), "Callback")]
    public class when_a_target_property_is_first_bound_to_a_source_value_that_is_different
    {
        private const double ExpectedWidth = 10d;

        private static TestBindingObject source;

        private static TestBindingObject target;

        private Establish context = () =>
            {
                source = new TestBindingObject { Width = ExpectedWidth };
                target = new TestBindingObject();
            };

        private Because of = () =>
            {
                IObservable<double> fromSource = BindingFactory.CreateOneWay(source, TestBindingObject.WidthProperty);
                target.Bind(TestBindingObject.WidthProperty, fromSource);
            };

        private It should_call_the_target_property_changed_callback =
            () => target.WidthPropertyChangedCalledbackCount.ShouldEqual(1);

        private It should_update_the_target = () => target.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(ReactiveObject), "Callback")]
    public class when_a_bound_value_is_changed_three_times
    {
        private const double ExpectedWidth = 10d;

        private static TestBindingObject source;

        private static TestBindingObject target;

        private Establish context = () =>
            {
                source = new TestBindingObject();
                target = new TestBindingObject();

                IObservable<double> fromSource = BindingFactory.CreateOneWay(source, TestBindingObject.WidthProperty);
                target.Bind(TestBindingObject.WidthProperty, fromSource);
            };

        private Because of = () =>
            {
                source.Width = ExpectedWidth + 1;
                source.Width = ExpectedWidth + 2;
                source.Width = ExpectedWidth;
            };

        private It should_call_the_target_property_changed_callback =
            () => target.WidthPropertyChangedCalledbackCount.ShouldEqual(3);

        private It should_update_the_target = () => target.Width.ShouldEqual(ExpectedWidth);
    }
}