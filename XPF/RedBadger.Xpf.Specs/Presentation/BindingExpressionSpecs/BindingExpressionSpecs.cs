/*//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.Presentation.BindingExpressionSpecs
{
    using System;

    using Machine.Specifications;

    using Moq;

    using RedBadger.Xpf.Graphics;
    using RedBadger.Xpf.Presentation;
    using RedBadger.Xpf.Presentation.Controls;
    using RedBadger.Xpf.Presentation.Data;
    using RedBadger.Xpf.Presentation.Media;

    using It = Machine.Specifications.It;

    [Subject(typeof(BindingExpression), "Binding")]
    public class when_the_width_of_a_textblock_is_set_through_a_binding
    {
        private const double ExpectedWidth = 100;

        private static MyBindingObject myBindingObject;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                textBlock.SetBinding(UIElement.WidthProperty, new Binding("MyWidth") { Source = myBindingObject });
            };

        private Because of = () => myBindingObject.MyWidth = ExpectedWidth;

        private It should_have_the_correct_width = () => textBlock.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(BindingExpression), "Binding")]
    public class when_the_width_of_a_textblock_is_set_and_the_binding_is_two_way
    {
        private const double ExpectedWidth = 100;

        private static MyBindingObject myBindingObject;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                textBlock.SetBinding(
                    UIElement.WidthProperty, 
                    new Binding("MyWidth") { Source = myBindingObject, Mode = BindingMode.TwoWay });
            };

        private Because of = () => textBlock.Width = ExpectedWidth;

        private It should_update_the_bound_property = () => myBindingObject.MyWidth.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(BindingExpression), "Binding")]
    public class when_a_binding_is_changed
    {
        private const double ExpectedWidth = 100;

        private static MyBindingObject myBindingObject1;

        private static MyBindingObject myBindingObject2;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject1 = new MyBindingObject();
                myBindingObject2 = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                textBlock.SetBinding(UIElement.WidthProperty, new Binding("MyWidth") { Source = myBindingObject1 });
                textBlock.SetBinding(UIElement.WidthProperty, new Binding("MyWidth") { Source = myBindingObject2 });
            };

        private Because of = () =>
            {
                myBindingObject2.MyWidth = ExpectedWidth;
                myBindingObject1.MyWidth = ExpectedWidth + 1;
            };

        private It should_use_the_latest_binding = () => textBlock.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(BindingExpression), "Binding")]
    public class when_a_binding_is_cleared
    {
        private const double ExpectedWidth = 100;

        private static MyBindingObject myBindingObject1;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject1 = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                textBlock.SetBinding(UIElement.WidthProperty, new Binding("MyWidth") { Source = myBindingObject1 });
            };

        private Because of = () =>
            {
                myBindingObject1.MyWidth = ExpectedWidth;
                textBlock.ClearBinding(UIElement.WidthProperty);
                myBindingObject1.MyWidth = ExpectedWidth + 1;
            };

        private It should_not_use_the_binding = () => double.IsNaN(textBlock.Width).ShouldBeTrue();
    }

    [Subject(typeof(BindingExpression), "Binding Mode")]
    public class when_the_binding_mode_is_default
    {
        private static Exception exception;

        private static Mock<UIElement> textBlock;

        private Establish context = () => textBlock = new Mock<UIElement> { CallBase = true };

        private Because of =
            () =>
            exception =
            Catch.Exception(
                () => textBlock.Object.SetBinding(UIElement.WidthProperty, new Binding { Mode = BindingMode.Default }));

        private It should_not_throw_an_exception = () => exception.ShouldBeNull();
    }

    [Subject(typeof(BindingExpression), "Binding Mode")]
    public class when_the_binding_mode_is_one_time
    {
        private static Exception exception;

        private static Mock<UIElement> textBlock;

        private Establish context = () => textBlock = new Mock<UIElement> { CallBase = true };

        private Because of =
            () =>
            exception =
            Catch.Exception(
                () => textBlock.Object.SetBinding(UIElement.WidthProperty, new Binding { Mode = BindingMode.OneTime }));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<NotSupportedException>();
    }

    [Subject(typeof(BindingExpression), "Binding Mode")]
    public class when_the_binding_mode_is_one_way_to_source
    {
        private static Exception exception;

        private static Mock<UIElement> textBlock;

        private Establish context = () => textBlock = new Mock<UIElement> { CallBase = true };

        private Because of =
            () =>
            exception =
            Catch.Exception(
                () =>
                textBlock.Object.SetBinding(UIElement.WidthProperty, new Binding { Mode = BindingMode.OneWayToSource }));

        private It should_throw_an_exception = () => exception.ShouldBeOfType<NotSupportedException>();
    }

    [Subject(typeof(BindingExpression), "Type Conversion")]
    public class when_the_property_value_is_of_a_type_derived_from_the_property_type
    {
        private static Border border;

        private static BorderBrushBindingObject myBindingObject;

        private Establish context = () =>
            {
                myBindingObject = new BorderBrushBindingObject();
                border = new Border();
                border.SetBinding(Border.BorderBrushProperty, new Binding("Brush") { Source = myBindingObject });
            };

        private Because of = () => myBindingObject.Brush = new SolidColorBrush(Colors.Blue);

        private It should_bind_the_value_of_the_derived_type =
            () => border.BorderBrush.ShouldBeOfType<SolidColorBrush>();
    }

    [Subject(typeof(BindingExpression), "Type Conversion")]
    public class when_the_property_value_is_of_a_type_that_doesnt_implement_IConvertible
    {
        private static TextBlock textBlock;

        private Establish context = () => textBlock = new TextBlock(new Mock<ISpriteFont>().Object);

        private Because of = () => textBlock.SetBinding(TextBlock.TextProperty, new Binding { Source = Colors.Red });

        private It should_convert_the_value_to_a_string_representation =
            () => textBlock.Text.ShouldEqual(Colors.Red.ToString());
    }
}*/