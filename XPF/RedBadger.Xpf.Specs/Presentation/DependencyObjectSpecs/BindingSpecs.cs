//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

namespace RedBadger.Xpf.Specs.Presentation.DependencyObjectSpecs
{
    using System;
    using System.Linq;

    using Machine.Specifications;

    using Moq;

    using RedBadger.Xpf.Graphics;
    using RedBadger.Xpf.Presentation;
    using RedBadger.Xpf.Presentation.Controls;
    using RedBadger.Xpf.Presentation.Media;

    using It = Machine.Specifications.It;

    [Subject(typeof(DependencyObject), "Binding")]
    public class when_a_binding_is_one_way_from_source
    {
        private const double ExpectedWidth = 100;

        private static MyBindingObject myBindingObject;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                textBlock.Bind(UIElement.WidthProperty, myBindingObject.MyWidthOut);
            };

        private Because of = () => myBindingObject.MyWidth = ExpectedWidth;

        private It should_have_the_correct_width = () => textBlock.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(DependencyObject), "Binding")]
    public class when_a_binding_is_one_way_to_source
    {
        private const double ExpectedWidth = 100;

        private static MyBindingObject myBindingObject;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                textBlock.Bind(UIElement.WidthProperty, myBindingObject.MyWidthIn);
            };

        private Because of = () => textBlock.Width = ExpectedWidth;

        private It should_update_the_bound_property = () => myBindingObject.MyWidth.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(DependencyObject), "Binding")]
    public class when_a_binding_is_changed
    {
        private const double ExpectedWidth = 100;

        private static MyBindingObject myBindingObject1;

        private static MyBindingObject myBindingObject2;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject1 = new MyBindingObject();
                myBindingObject2 = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                IDisposable binding = textBlock.Bind(UIElement.WidthProperty, myBindingObject1.MyWidthOut);
                binding.Dispose();
                textBlock.Bind(UIElement.WidthProperty, myBindingObject2.MyWidthOut);
            };

        private Because of = () =>
            {
                myBindingObject2.MyWidth = ExpectedWidth;
                myBindingObject1.MyWidth = ExpectedWidth + 1;
            };

        private It should_use_the_latest_binding = () => textBlock.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(DependencyObject), "Binding")]
    public class when_a_binding_is_cleared
    {
        private const double ExpectedWidth = 100;

        private static IDisposable binding;

        private static MyBindingObject myBindingObject;

        private static TextBlock textBlock;

        private Establish context = () =>
            {
                myBindingObject = new MyBindingObject();
                textBlock = new TextBlock(new Mock<ISpriteFont>().Object);
                binding = textBlock.Bind(UIElement.WidthProperty, myBindingObject.MyWidthOut);
            };

        private Because of = () =>
            {
                myBindingObject.MyWidth = ExpectedWidth;
                binding.Dispose();
                myBindingObject.MyWidth = ExpectedWidth + 1;
            };

        private It should_not_use_the_binding = () => textBlock.Width.ShouldEqual(ExpectedWidth);
    }

    [Subject(typeof(DependencyObject), "Type Conversion")]
    public class when_the_property_value_is_of_a_type_derived_from_the_property_type
    {
        private static Border border;

        private static BorderBrushBindingObject myBindingObject;

        private Establish context = () =>
            {
                myBindingObject = new BorderBrushBindingObject();
                border = new Border();
                border.Bind(Border.BorderBrushProperty, myBindingObject.BrushProperty);
            };

        private Because of = () => myBindingObject.Brush = new SolidColorBrush(Colors.Blue);

        private It should_bind_the_value_of_the_derived_type =
            () => border.BorderBrush.ShouldBeOfType<SolidColorBrush>();
    }
/*

    [Subject(typeof(DependencyObject), "Object Binding")]
    public class when_binding_to_an_object
    {
        private static TextBlock textBlock;

        private Establish context = () => textBlock = new TextBlock(new Mock<ISpriteFont>().Object);

        private Because of = () => textBlock.Bind(TextBlock.TextProperty, Observable.Return(Colors.Red.ToString()));

        private It should_convert_the_value_to_a_string_representation =
            () => textBlock.Text.ShouldEqual(Colors.Red.ToString());
    }
*/
}